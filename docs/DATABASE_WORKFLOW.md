# Database Workflow for Multi-Computer Development

This document explains how to handle database schema changes when working across multiple computers.

## Overview

The database system is designed to automatically handle schema changes when you pull updates from the repository. Here's how it works:

1. **Automatic Migration Detection**: The `postinstall` script runs `db:migrate:auto` which checks for pending migrations
2. **Schema Change Handling**: When schema changes are detected, migrations are applied automatically
3. **Seamless Updates**: Pull changes and run `npm install` to automatically handle database updates

## Quick Start

### First Time Setup

```bash
# 1. Clone the repository
git clone <your-repo-url>
cd vgm-saas

# 2. Install dependencies (this will also run database setup)
npm install

# 3. Set up environment variables
npm run db:setup

# 4. Start development
npm run dev:setup
```

### Daily Development Workflow

```bash
# 1. Pull latest changes
git pull origin main

# 2. Install dependencies (automatically handles migrations)
npm install

# 3. Start development
npm run dev
```

## Available Commands

### Interactive Commands (Recommended for Development)

```bash
# Interactive migration and seeding
npm run db:migrate

# Check database status
npm run db:status

# Reset database with test data
npm run db:reset
```

### Automated Commands (For CI/CD)

```bash
# Automated migration and seeding
npm run db:migrate:auto

# Automated migration with auto-reset (destructive)
npm run db:migrate:reset
```

### Utility Commands

```bash
# Generate new migration files
npm run db:generate

# Push schema changes directly (development only)
npm run db:push

# Open Drizzle Studio
npm run db:studio

# Manual seeding only
npm run db:seed
```

## Making Schema Changes

### Step-by-Step Process

1. **Make schema changes** in `lib/db/schema.ts`
2. **Generate migration**:
   ```bash
   npm run db:generate
   ```
3. **Review the generated migration** in `lib/db/migrations/`
4. **Test locally**:
   ```bash
   npm run db:migrate
   ```
5. **Commit and push** both schema changes and migration files
6. **On other computers**: Pull changes and run `npm install`

### Example Workflow

```bash
# Computer A: Make schema changes
# Edit lib/db/schema.ts
npm run db:generate
npm run db:migrate
git add .
git commit -m "Add new user fields"
git push

# Computer B: Pull changes
git pull origin main
npm install  # Automatically handles migrations
npm run dev
```

## Migration Types

### Safe Migrations (Recommended)

These migrations can be applied without data loss:

- Adding new columns with default values
- Adding new tables
- Adding indexes
- Adding constraints that don't conflict with existing data

### Destructive Migrations (Use with Caution)

These migrations may cause data loss:

- Dropping columns
- Dropping tables
- Changing column types
- Removing constraints

For destructive migrations, consider:

1. Backing up data first
2. Using `npm run db:reset` to start fresh
3. Manually migrating data if needed

## Troubleshooting

### Common Issues

#### "Database connection failed"

```bash
# Check if .env file exists
ls -la .env

# If missing, run setup
npm run db:setup
```

#### "Pending migrations detected"

```bash
# Apply migrations interactively
npm run db:migrate

# Or apply automatically
npm run db:migrate:auto
```

#### "Schema mismatch"

```bash
# Reset database (destructive)
npm run db:reset

# Or check status first
npm run db:status
```

#### "Migration conflicts"

If you have conflicting migrations:

1. **Backup your data** (if important)
2. **Reset the database**:
   ```bash
   npm run db:reset
   ```
3. **Apply migrations**:
   ```bash
   npm run db:migrate
   ```

### Development vs Production

#### Development

- Use `npm run db:reset` freely
- Use `npm run db:push` for quick schema changes
- Test migrations thoroughly before committing

#### Production

- Never use `npm run db:reset`
- Always use proper migrations
- Test migrations on staging first
- Backup before applying migrations

## Best Practices

### For Schema Changes

1. **Always generate migrations** for schema changes
2. **Test migrations locally** before committing
3. **Include migration files** in your commits
4. **Use descriptive migration names** (auto-generated by Drizzle)
5. **Review migration files** before committing

### For Team Collaboration

1. **Pull changes frequently** to avoid conflicts
2. **Run `npm install`** after pulling to apply migrations
3. **Communicate schema changes** with your team
4. **Use the git pre-commit hook** to remind about migrations

### For Data Management

1. **Use test data** for development
2. **Backup important data** before destructive operations
3. **Use Drizzle Studio** to inspect data
4. **Keep seed data up to date** with schema changes

## Environment Variables

Make sure these are set in your `.env` file:

```env
POSTGRES_URL=postgresql://username:password@host:port/database
AUTH_SECRET=your-secret-key-here
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
BASE_URL=http://localhost:3000
```

## Local Database Setup

### Using Docker (Recommended)

```bash
# Start local PostgreSQL
docker compose up -d

# Or use the setup script
npm run db:setup
```

### Using External Database

1. Set up a PostgreSQL database (e.g., on Vercel, Supabase, etc.)
2. Update `POSTGRES_URL` in your `.env` file
3. Run `npm run db:migrate:auto` to set up the database

## Monitoring and Debugging

### Check Database Status

```bash
npm run db:status
```

This will show:

- Number of users and teams
- Pending migrations
- Latest migration applied
- Database connection status

### View Database in Browser

```bash
npm run db:studio
```

This opens Drizzle Studio where you can:

- Browse tables and data
- Run queries
- Export data
- Inspect schema

### Logs and Debugging

- Check console output for migration status
- Use `npm run db:migrate` for interactive debugging
- Review migration files in `lib/db/migrations/`

## Summary

The database workflow is designed to be seamless across multiple computers:

1. **Automatic**: `npm install` handles migrations automatically
2. **Safe**: Interactive prompts for destructive operations
3. **Flexible**: Multiple commands for different scenarios
4. **Reliable**: Proper error handling and status checking

Follow the workflow, use the recommended commands, and you'll have a smooth development experience across all your computers!
